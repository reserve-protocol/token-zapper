{
  "language": "Solidity",
  "sources": {
    "contracts/Aerodrome.sol": {
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\ninterface IAerodromeRouter {\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n        address factory;\n    }\n\n    error ETHTransferFailed();\n    error Expired();\n    error InsufficientAmount();\n    error InsufficientAmountA();\n    error InsufficientAmountB();\n    error InsufficientAmountADesired();\n    error InsufficientAmountBDesired();\n    error InsufficientAmountAOptimal();\n    error InsufficientLiquidity();\n    error InsufficientOutputAmount();\n    error InvalidAmountInForETHDeposit();\n    error InvalidTokenInForETHDeposit();\n    error InvalidPath();\n    error InvalidRouteA();\n    error InvalidRouteB();\n    error OnlyWETH();\n    error PoolDoesNotExist();\n    error PoolFactoryDoesNotExist();\n    error SameAddresses();\n    error ZeroAddress();\n\n    /// @notice Address of FactoryRegistry.sol\n    function factoryRegistry() external view returns (address);\n\n    /// @notice Address of Protocol PoolFactory.sol\n    function defaultFactory() external view returns (address);\n\n    /// @dev Struct containing information necessary to zap in and out of pools\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           Stable or volatile pool\n    /// @param factory          factory of pool\n    /// @param amountOutMinA    Minimum amount expected from swap leg of zap via routesA\n    /// @param amountOutMinB    Minimum amount expected from swap leg of zap via routesB\n    /// @param amountAMin       Minimum amount of tokenA expected from liquidity leg of zap\n    /// @param amountBMin       Minimum amount of tokenB expected from liquidity leg of zap\n    struct Zap {\n        address tokenA;\n        address tokenB;\n        bool stable;\n        address factory;\n        uint256 amountOutMinA;\n        uint256 amountOutMinB;\n        uint256 amountAMin;\n        uint256 amountBMin;\n    }\n\n    /// @notice Sort two tokens by which address value is less than the other\n    /// @param tokenA   Address of token to sort\n    /// @param tokenB   Address of token to sort\n    /// @return token0  Lower address value between tokenA and tokenB\n    /// @return token1  Higher address value between tokenA and tokenB\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n\n    /// @notice Calculate the address of a pool by its' factory.\n    ///         Used by all Router functions containing a `Route[]` or `_factory` argument.\n    ///         Reverts if _factory is not approved by the FactoryRegistry\n    /// @dev Returns a randomly generated address for a nonexistent pool\n    /// @param tokenA   Address of token to query\n    /// @param tokenB   Address of token to query\n    /// @param stable   True if pool is stable, false if volatile\n    /// @param _factory Address of factory which created the pool\n    function poolFor(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory\n    ) external view returns (address pool);\n\n    /// @notice Fetch and sort the reserves for a pool\n    /// @param tokenA       .\n    /// @param tokenB       .\n    /// @param stable       True if pool is stable, false if volatile\n    /// @param _factory     Address of PoolFactory for tokenA and tokenB\n    /// @return reserveA    Amount of reserves of the sorted token A\n    /// @return reserveB    Amount of reserves of the sorted token B\n    function getReserves(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory\n    ) external view returns (uint256 reserveA, uint256 reserveB);\n\n    /// @notice Perform chained getAmountOut calculations on any number of pools\n    function getAmountsOut(uint256 amountIn, Route[] memory routes) external view returns (uint256[] memory amounts);\n\n    // **** ADD LIQUIDITY ****\n\n    /// @notice Quote the amount deposited into a Pool\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           True if pool is stable, false if volatile\n    /// @param _factory         Address of PoolFactory for tokenA and tokenB\n    /// @param amountADesired   Amount of tokenA desired to deposit\n    /// @param amountBDesired   Amount of tokenB desired to deposit\n    /// @return amountA         Amount of tokenA to actually deposit\n    /// @return amountB         Amount of tokenB to actually deposit\n    /// @return liquidity       Amount of liquidity token returned from deposit\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    ) external view returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Quote the amount of liquidity removed from a Pool\n    /// @param tokenA       .\n    /// @param tokenB       .\n    /// @param stable       True if pool is stable, false if volatile\n    /// @param _factory     Address of PoolFactory for tokenA and tokenB\n    /// @param liquidity    Amount of liquidity to remove\n    /// @return amountA     Amount of tokenA received\n    /// @return amountB     Amount of tokenB received\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 liquidity\n    ) external view returns (uint256 amountA, uint256 amountB);\n\n    /// @notice Add liquidity of two tokens to a Pool\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           True if pool is stable, false if volatile\n    /// @param amountADesired   Amount of tokenA desired to deposit\n    /// @param amountBDesired   Amount of tokenB desired to deposit\n    /// @param amountAMin       Minimum amount of tokenA to deposit\n    /// @param amountBMin       Minimum amount of tokenB to deposit\n    /// @param to               Recipient of liquidity token\n    /// @param deadline         Deadline to receive liquidity\n    /// @return amountA         Amount of tokenA to actually deposit\n    /// @return amountB         Amount of tokenB to actually deposit\n    /// @return liquidity       Amount of liquidity token returned from deposit\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    /// @notice Add liquidity of a token and WETH (transferred as ETH) to a Pool\n    /// @param token                .\n    /// @param stable               True if pool is stable, false if volatile\n    /// @param amountTokenDesired   Amount of token desired to deposit\n    /// @param amountTokenMin       Minimum amount of token to deposit\n    /// @param amountETHMin         Minimum amount of ETH to deposit\n    /// @param to                   Recipient of liquidity token\n    /// @param deadline             Deadline to add liquidity\n    /// @return amountToken         Amount of token to actually deposit\n    /// @return amountETH           Amount of tokenETH to actually deposit\n    /// @return liquidity           Amount of liquidity token returned from deposit\n    function addLiquidityETH(\n        address token,\n        bool stable,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    // **** REMOVE LIQUIDITY ****\n\n    /// @notice Remove liquidity of two tokens from a Pool\n    /// @param tokenA       .\n    /// @param tokenB       .\n    /// @param stable       True if pool is stable, false if volatile\n    /// @param liquidity    Amount of liquidity to remove\n    /// @param amountAMin   Minimum amount of tokenA to receive\n    /// @param amountBMin   Minimum amount of tokenB to receive\n    /// @param to           Recipient of tokens received\n    /// @param deadline     Deadline to remove liquidity\n    /// @return amountA     Amount of tokenA received\n    /// @return amountB     Amount of tokenB received\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    /// @notice Remove liquidity of a token and WETH (returned as ETH) from a Pool\n    /// @param token            .\n    /// @param stable           True if pool is stable, false if volatile\n    /// @param liquidity        Amount of liquidity to remove\n    /// @param amountTokenMin   Minimum amount of token to receive\n    /// @param amountETHMin     Minimum amount of ETH to receive\n    /// @param to               Recipient of liquidity token\n    /// @param deadline         Deadline to receive liquidity\n    /// @return amountToken     Amount of token received\n    /// @return amountETH       Amount of ETH received\n    function removeLiquidityETH(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    /// @notice Remove liquidity of a fee-on-transfer token and WETH (returned as ETH) from a Pool\n    /// @param token            .\n    /// @param stable           True if pool is stable, false if volatile\n    /// @param liquidity        Amount of liquidity to remove\n    /// @param amountTokenMin   Minimum amount of token to receive\n    /// @param amountETHMin     Minimum amount of ETH to receive\n    /// @param to               Recipient of liquidity token\n    /// @param deadline         Deadline to receive liquidity\n    /// @return amountETH       Amount of ETH received\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    // **** SWAP ****\n\n    /// @notice Swap one token for another\n    /// @param amountIn     Amount of token in\n    /// @param amountOutMin Minimum amount of desired token received\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    /// @return amounts     Array of amounts returned per route\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    /// @notice Swap ETH for a token\n    /// @param amountOutMin Minimum amount of desired token received\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    /// @return amounts     Array of amounts returned per route\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    /// @notice Swap a token for WETH (returned as ETH)\n    /// @param amountIn     Amount of token in\n    /// @param amountOutMin Minimum amount of desired ETH\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    /// @return amounts     Array of amounts returned per route\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    /// @notice Swap one token for another without slippage protection\n    /// @return amounts     Array of amounts to swap  per route\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    function UNSAFE_swapExactTokensForTokens(\n        uint256[] memory amounts,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory);\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n\n    /// @notice Swap one token for another supporting fee-on-transfer tokens\n    /// @param amountIn     Amount of token in\n    /// @param amountOutMin Minimum amount of desired token received\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external;\n\n    /// @notice Swap ETH for a token supporting fee-on-transfer tokens\n    /// @param amountOutMin Minimum amount of desired token received\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    /// @notice Swap a token for WETH (returned as ETH) supporting fee-on-transfer tokens\n    /// @param amountIn     Amount of token in\n    /// @param amountOutMin Minimum amount of desired ETH\n    /// @param routes       Array of trade routes used in the swap\n    /// @param to           Recipient of the tokens received\n    /// @param deadline     Deadline to receive tokens\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Route[] calldata routes,\n        address to,\n        uint256 deadline\n    ) external;\n\n    /// @notice Zap a token A into a pool (B, C). (A can be equal to B or C).\n    ///         Supports standard ERC20 tokens only (i.e. not fee-on-transfer tokens etc).\n    ///         Slippage is required for the initial swap.\n    ///         Additional slippage may be required when adding liquidity as the\n    ///         price of the token may have changed.\n    /// @param tokenIn      Token you are zapping in from (i.e. input token).\n    /// @param amountInA    Amount of input token you wish to send down routesA\n    /// @param amountInB    Amount of input token you wish to send down routesB\n    /// @param zapInPool    Contains zap struct information. See Zap struct.\n    /// @param routesA      Route used to convert input token to tokenA\n    /// @param routesB      Route used to convert input token to tokenB\n    /// @param to           Address you wish to mint liquidity to.\n    /// @param stake        Auto-stake liquidity in corresponding gauge.\n    /// @return liquidity   Amount of LP tokens created from zapping in.\n    function zapIn(\n        address tokenIn,\n        uint256 amountInA,\n        uint256 amountInB,\n        Zap calldata zapInPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB,\n        address to,\n        bool stake\n    ) external payable returns (uint256 liquidity);\n\n    /// @notice Zap out a pool (B, C) into A.\n    ///         Supports standard ERC20 tokens only (i.e. not fee-on-transfer tokens etc).\n    ///         Slippage is required for the removal of liquidity.\n    ///         Additional slippage may be required on the swap as the\n    ///         price of the token may have changed.\n    /// @param tokenOut     Token you are zapping out to (i.e. output token).\n    /// @param liquidity    Amount of liquidity you wish to remove.\n    /// @param zapOutPool   Contains zap struct information. See Zap struct.\n    /// @param routesA      Route used to convert tokenA into output token.\n    /// @param routesB      Route used to convert tokenB into output token.\n    function zapOut(\n        address tokenOut,\n        uint256 liquidity,\n        Zap calldata zapOutPool,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    ) external;\n\n    /// @notice Used to generate params required for zapping in.\n    ///         Zap in => remove liquidity then swap.\n    ///         Apply slippage to expected swap values to account for changes in reserves in between.\n    /// @dev Output token refers to the token you want to zap in from.\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           .\n    /// @param _factory         .\n    /// @param amountInA        Amount of input token you wish to send down routesA\n    /// @param amountInB        Amount of input token you wish to send down routesB\n    /// @param routesA          Route used to convert input token to tokenA\n    /// @param routesB          Route used to convert input token to tokenB\n    /// @return amountOutMinA   Minimum output expected from swapping input token to tokenA.\n    /// @return amountOutMinB   Minimum output expected from swapping input token to tokenB.\n    /// @return amountAMin      Minimum amount of tokenA expected from depositing liquidity.\n    /// @return amountBMin      Minimum amount of tokenB expected from depositing liquidity.\n    function generateZapInParams(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 amountInA,\n        uint256 amountInB,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    ) external view returns (uint256 amountOutMinA, uint256 amountOutMinB, uint256 amountAMin, uint256 amountBMin);\n\n    /// @notice Used to generate params required for zapping out.\n    ///         Zap out => swap then add liquidity.\n    ///         Apply slippage to expected liquidity values to account for changes in reserves in between.\n    /// @dev Output token refers to the token you want to zap out of.\n    /// @param tokenA           .\n    /// @param tokenB           .\n    /// @param stable           .\n    /// @param _factory         .\n    /// @param liquidity        Amount of liquidity being zapped out of into a given output token.\n    /// @param routesA          Route used to convert tokenA into output token.\n    /// @param routesB          Route used to convert tokenB into output token.\n    /// @return amountOutMinA   Minimum output expected from swapping tokenA into output token.\n    /// @return amountOutMinB   Minimum output expected from swapping tokenB into output token.\n    /// @return amountAMin      Minimum amount of tokenA expected from withdrawing liquidity.\n    /// @return amountBMin      Minimum amount of tokenB expected from withdrawing liquidity.\n    function generateZapOutParams(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        address _factory,\n        uint256 liquidity,\n        Route[] calldata routesA,\n        Route[] calldata routesB\n    ) external view returns (uint256 amountOutMinA, uint256 amountOutMinB, uint256 amountAMin, uint256 amountBMin);\n\n    /// @notice Used by zapper to determine appropriate ratio of A to B to deposit liquidity. Assumes stable pool.\n    /// @dev Returns stable liquidity ratio of B to (A + B).\n    ///      E.g. if ratio is 0.4, it means there is more of A than there is of B.\n    ///      Therefore you should deposit more of token A than B.\n    /// @param tokenA   tokenA of stable pool you are zapping into.\n    /// @param tokenB   tokenB of stable pool you are zapping into.\n    /// @param factory  Factory that created stable pool.\n    /// @return ratio   Ratio of token0 to token1 required to deposit into zap.\n    function quoteStableLiquidityRatio(\n        address tokenA,\n        address tokenB,\n        address factory\n    ) external view returns (uint256 ratio);\n}\n\ninterface IMixedRouteQuoterV1 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return v3SqrtPriceX96AfterList List of the sqrt price after the swap for each v3 pool in the path, 0 for v2 pools\n    /// @return v3InitializedTicksCrossedList List of the initialized ticks that the swap crossed for each v3 pool in the path, 0 for v2 pools\n    /// @return v3SwapGasEstimate The estimate of the gas that the v3 swaps in the path consume\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory v3SqrtPriceX96AfterList,\n            uint32[] memory v3InitializedTicksCrossedList,\n            uint256 v3SwapGasEstimate\n        );\n\n    struct QuoteExactInputSingleV3Params {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        int24 tickSpacing;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct QuoteExactInputSingleV2Params {\n        address tokenIn;\n        address tokenOut;\n        bool stable;\n        uint256 amountIn;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// tickSpacing The tickSpacing of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingleV3(QuoteExactInputSingleV3Params memory params)\n        external\n        returns (uint256 amountOut, uint160 sqrtPriceX96After, uint32 initializedTicksCrossed, uint256 gasEstimate);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single V2 pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleV2Params`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// stable The boolean representing volatile (false) or stable (true)\n    /// amountIn The desired input amount\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingleV2(QuoteExactInputSingleV2Params memory params)\n        external\n        returns (uint256 amountOut);\n\n    /// @dev ExactOutput swaps are not supported by this new Quoter which is specialized for supporting routes\n    ///      crossing both V2 liquidity pairs and V3 pools.\n    /// @deprecated quoteExactOutputSingle and exactOutput. Use QuoterV2 instead.\n}\n\ninterface IAerodromeFactory {\n    event SetFeeManager(address feeManager);\n    event SetPauser(address pauser);\n    event SetPauseState(bool state);\n    event SetVoter(address voter);\n    event PoolCreated(address indexed token0, address indexed token1, bool indexed stable, address pool, uint256);\n    event SetCustomFee(address indexed pool, uint256 fee);\n\n    error FeeInvalid();\n    error FeeTooHigh();\n    error InvalidPool();\n    error NotFeeManager();\n    error NotPauser();\n    error NotVoter();\n    error PoolAlreadyExists();\n    error SameAddress();\n    error ZeroFee();\n    error ZeroAddress();\n\n    /// @notice returns the number of pools created from this factory\n    function allPoolsLength() external view returns (uint256);\n\n    /// @notice Is a valid pool created by this factory.\n    /// @param .\n    function isPool(address pool) external view returns (bool);\n\n    /// @notice Support for v3-style pools which wraps around getPool(tokenA,tokenB,stable)\n    /// @dev fee is converted to stable boolean.\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param fee  1 if stable, 0 if volatile, else returns address(0)\n    function getPool(address tokenA, address tokenB, int24 fee) external view returns (address);\n\n    /// @dev Only called once to set to Voter.sol - Voter does not have a function\n    ///      to call this contract method, so once set it's immutable.\n    ///      This also follows convention of setVoterAndDistributor() in VotingEscrow.sol\n    /// @param _voter .\n    function setVoter(address _voter) external;\n\n    function setPauser(address _pauser) external;\n\n    function setPauseState(bool _state) external;\n\n    function setFeeManager(address _feeManager) external;\n\n    /// @notice Set default fee for stable and volatile pools.\n    /// @dev Throws if higher than maximum fee.\n    ///      Throws if fee is zero.\n    /// @param _stable Stable or volatile pool.\n    /// @param _fee .\n    function setFee(bool _stable, uint256 _fee) external;\n\n    /// @notice Set overriding fee for a pool from the default\n    /// @dev A custom fee of zero means the default fee will be used.\n    function setCustomFee(address _pool, uint256 _fee) external;\n\n    /// @notice Returns fee for a pool, as custom fees are possible.\n    function getFee(address _pool, bool _stable) external view returns (uint256);\n\n    /// @notice Create a pool given two tokens and if they're stable/volatile\n    /// @dev token order does not matter\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param stable .\n    function createPool(address tokenA, address tokenB, bool stable) external returns (address pool);\n\n    /// @notice Support for v3-style pools which wraps around createPool(tokena,tokenB,stable)\n    /// @dev fee is converted to stable boolean\n    /// @dev token order does not matter\n    /// @param tokenA .\n    /// @param tokenB .\n    /// @param fee 1 if stable, 0 if volatile, else revert\n    function createPool(address tokenA, address tokenB, uint24 fee) external returns (address pool);\n\n    function isPaused() external view returns (bool);\n\n    function voter() external view returns (address);\n\n    function implementation() external view returns (address);\n}\n\nstruct SwapLp {\n  address lp;\n  int24 poolType;\n  address token0;\n  address token1;\n  address factory;\n  uint256 poolFee;\n}\n\ninterface IAerodromeSugar {\n  function forSwaps(uint256 limit, uint256 offset) external view returns (SwapLp[]memory);\n}\n\n\n\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        int24 tickSpacing;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n}\ncontract SlipstreamRouterCall {\n    function exactInputSingle(\n        uint256 amountIn,\n        uint256 _expected,\n        address router,\n        bytes calldata encodedRouterCall\n    ) external returns (uint256) {\n        (ISwapRouter.ExactInputSingleParams memory decodedCall) = abi.decode(\n            encodedRouterCall,\n            (ISwapRouter.ExactInputSingleParams)\n        );\n        decodedCall.amountIn = amountIn;\n        decodedCall.amountOutMinimum = _expected;\n        return ISwapRouter(router).exactInputSingle(decodedCall);\n    }\n\n    function exactInput(\n        uint256 amountIn,\n        uint256 _expected,\n        address router,\n        address recipient,\n        bytes memory path\n    ) external returns (uint256) {\n        ISwapRouter.ExactInputParams memory decodedCall = ISwapRouter.ExactInputParams({\n            path: path,\n            recipient: recipient,\n            deadline: block.timestamp + 1000,\n            amountIn: amountIn,\n            amountOutMinimum: _expected\n        });\n        decodedCall.amountIn = amountIn;\n        decodedCall.amountOutMinimum = _expected;\n        return ISwapRouter(router).exactInput(decodedCall);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}