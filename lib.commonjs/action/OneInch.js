"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OneInchAction = void 0;
const Address_1 = require("../base/Address");
const Action_1 = require("./Action");
const Approval_1 = require("../base/Approval");
// OneInch actions should only be dynamically generated by the Searcher and not be added to the exchange-graph
class OneInchAction extends (0, Action_1.Action)('1inch') {
    universe;
    actionQuote;
    async plan(planner, _, destination) {
        throw new Error('Method not implemented.');
    }
    gasEstimate() {
        return BigInt(this.actionQuote.tx.gas);
    }
    toString() {
        return `OneInch(path=[...])`;
    }
    outputQty;
    async quote(_) {
        return [this.outputQty];
    }
    constructor(universe, inputToken, outputToken, actionQuote, slippagePercent) {
        super(Address_1.Address.fromHexString(actionQuote.tx.to), [inputToken], [outputToken], Action_1.InteractionConvention.ApprovalRequired, Action_1.DestinationOptions.Recipient, [new Approval_1.Approval(inputToken, Address_1.Address.fromHexString(actionQuote.tx.to))]);
        this.universe = universe;
        this.actionQuote = actionQuote;
        this.outputQty = outputToken
            .fromBigInt(BigInt(this.actionQuote.toAmount))
            .mul(outputToken.fromDecimal((100 - slippagePercent) / 100));
    }
    static createAction(universe, input, output, quote, slippagePercent) {
        return new OneInchAction(universe, input, output, quote, slippagePercent);
    }
}
exports.OneInchAction = OneInchAction;
//# sourceMappingURL=OneInch.js.map