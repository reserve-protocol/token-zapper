{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/IFolio.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\ninterface IFolio {\n    // === Events ===\n\n    event AuctionApproved(uint256 indexed auctionId, address indexed from, address indexed to, Auction auction);\n    event AuctionOpened(uint256 indexed auctionId, Auction auction);\n    event AuctionBid(uint256 indexed auctionId, uint256 sellAmount, uint256 buyAmount);\n    event AuctionClosed(uint256 indexed auctionId);\n\n    event FolioFeePaid(address indexed recipient, uint256 amount);\n    event ProtocolFeePaid(address indexed recipient, uint256 amount);\n\n    event BasketTokenAdded(address indexed token);\n    event BasketTokenRemoved(address indexed token);\n    event TVLFeeSet(uint256 newFee, uint256 feeAnnually);\n    event MintFeeSet(uint256 newFee);\n    event FeeRecipientSet(address indexed recipient, uint96 portion);\n    event AuctionDelaySet(uint256 newAuctionDelay);\n    event AuctionLengthSet(uint256 newAuctionLength);\n    event MandateSet(string newMandate);\n    event FolioKilled();\n\n    // === Errors ===\n\n    error Folio__FolioKilled();\n    error Folio__Unauthorized();\n\n    error Folio__EmptyAssets();\n    error Folio__BasketModificationFailed();\n\n    error Folio__FeeRecipientInvalidAddress();\n    error Folio__FeeRecipientInvalidFeeShare();\n    error Folio__BadFeeTotal();\n    error Folio__TVLFeeTooHigh();\n    error Folio__TVLFeeTooLow();\n    error Folio__MintFeeTooHigh();\n    error Folio__ZeroInitialShares();\n\n    error Folio__InvalidAsset();\n    error Folio__InvalidAssetAmount(address asset);\n\n    error Folio__InvalidAuctionLength();\n    error Folio__InvalidSellLimit();\n    error Folio__InvalidBuyLimit();\n    error Folio__AuctionCannotBeOpened();\n    error Folio__AuctionCannotBeOpenedPermissionlesslyYet();\n    error Folio__AuctionNotOngoing();\n    error Folio__AuctionCollision();\n    error Folio__InvalidPrices();\n    error Folio__AuctionTimeout();\n    error Folio__SlippageExceeded();\n    error Folio__InsufficientBalance();\n    error Folio__InsufficientBid();\n    error Folio__ExcessiveBid();\n    error Folio__InvalidAuctionTokens();\n    error Folio__InvalidAuctionDelay();\n    error Folio__InvalidAuctionTTL();\n    error Folio__TooManyFeeRecipients();\n    error Folio__InvalidArrayLengths();\n\n    // === Structures ===\n\n    struct FolioBasicDetails {\n        string name;\n        string symbol;\n        address[] assets;\n        uint256[] amounts; // {tok}\n        uint256 initialShares; // {share}\n    }\n\n    struct FolioAdditionalDetails {\n        uint256 auctionDelay; // {s}\n        uint256 auctionLength; // {s}\n        FeeRecipient[] feeRecipients;\n        uint256 tvlFee; // D18{1/s}\n        uint256 mintFee; // D18{1}\n        string mandate;\n    }\n\n    struct FeeRecipient {\n        address recipient;\n        uint96 portion; // D18{1}\n    }\n\n    struct BasketRange {\n        uint256 spot; // D27{buyTok/share}\n        uint256 low; // D27{buyTok/share} inclusive\n        uint256 high; // D27{buyTok/share} inclusive\n    }\n\n    struct Prices {\n        uint256 start; // D27{buyTok/sellTok}\n        uint256 end; // D27{buyTok/sellTok}\n    }\n\n    /// Auction states:\n    ///   - APPROVED: start == 0 && end == 0\n    ///   - OPEN: block.timestamp >= start && block.timestamp <= end\n    ///   - CLOSED: block.timestamp > end\n    struct Auction {\n        uint256 id;\n        IERC20 sell;\n        IERC20 buy;\n        BasketRange sellLimit; // D27{sellTok/share} min ratio of sell token in the basket, inclusive\n        BasketRange buyLimit; // D27{buyTok/share} max ratio of buy token in the basket, exclusive\n        Prices prices; // D27{buyTok/sellTok}\n        uint256 availableAt; // {s} inclusive\n        uint256 launchTimeout; // {s} inclusive\n        uint256 start; // {s} inclusive\n        uint256 end; // {s} inclusive\n        // === Gas optimization ===\n        uint256 k; // D18{1} price = startPrice * e ^ -kt\n    }\n\n    function distributeFees() external;\n}\n\n\ninterface IGovernanceDeployer {\n    struct GovParams {\n        // Basic Parameters\n        uint48 votingDelay; // {s}\n        uint32 votingPeriod; // {s}\n        uint256 proposalThreshold; // D18{1}\n        uint256 quorumPercent; // in percent, e.g 4 for 4%\n        uint256 timelockDelay; // {s}\n        // Roles\n        address[] guardians; // Canceller Role\n    }\n\n    function deployGovernanceWithTimelock(\n        IGovernanceDeployer.GovParams calldata govParams,\n        IVotes stToken\n    ) external returns (address governor, address timelock);\n}\n\nstruct GovRoles {\n  address[] existingTradeProposers;\n  address[] tradeLaunchers;\n  address[] vibesOfficers;\n}\n\n\ninterface IFolioDeployer {\n  error FolioDeployer__LengthMismatch();\n\n  event FolioDeployed(address indexed folioOwner, address indexed folio, address folioAdmin);\n  event GovernedFolioDeployed(\n      address indexed stToken,\n      address indexed folio,\n      address ownerGovernor,\n      address ownerTimelock,\n      address tradingGovernor,\n      address tradingTimelock\n  );\n\n\n  function folioImplementation() external view returns (address);\n\n\n  function deployFolio(\n    IFolio.FolioBasicDetails calldata basicDetails,\n    IFolio.FolioAdditionalDetails calldata additionalDetails,\n    address owner,\n    address[] memory auctionApprovers,\n    address[] memory auctionLaunchers,\n    address[] memory brandManagers\n  ) external returns (address folio, address proxyAdmin);\n\n  function deployGovernedFolio(\n    IVotes stToken,\n    IFolio.FolioBasicDetails calldata basicDetails,\n    IFolio.FolioAdditionalDetails calldata additionalDetails,\n    IGovernanceDeployer.GovParams calldata ownerGovParams,\n    IGovernanceDeployer.GovParams calldata tradingGovParams,\n    GovRoles calldata govRoles\n  )\n    external\n    returns (\n        address folio,\n        address proxyAdmin,\n        address ownerGovernor,\n        address ownerTimelock,\n        address tradingGovernor,\n        address tradingTimelock\n    );\n\n\n}\n"
    },
    "contracts/weiroll-helpers/DeployFolioHelper.sol": {
      "content": "\n// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IFolio, IVotes, GovRoles, IFolioDeployer, IGovernanceDeployer } from \"../IFolio.sol\";\n\nstruct DeployFolioConfig {\n  address deployer;\n  address expectedTokenAddress;\n  IFolio.FolioBasicDetails basicDetails;\n  IFolio.FolioAdditionalDetails additionalDetails;\n  GovRoles govRoles;\n\n  bool isGoverned;\n  IVotes stToken;\n  address owner;\n  IGovernanceDeployer.GovParams ownerGovParams;\n  IGovernanceDeployer.GovParams tradingGovParams;\n}\n\ninterface IDeployFolioHelper {\n  function deployFolio(DeployFolioConfig memory config) external returns (uint256);\n}\n\ncontract DeployFolioHelper {\n  function deployFolio(\n    bytes memory deployFolioConfig\n  ) external returns (uint256) {\n    DeployFolioConfig memory config = abi.decode(deployFolioConfig, (DeployFolioConfig));\n\n    uint256 initialShares = type(uint256).max;\n    for (uint256 i = 0; i < config.basicDetails.assets.length; i++) {\n      uint256 balance = IERC20(config.basicDetails.assets[i]).balanceOf(address(this));\n      if (balance == 0) {\n        revert('ZERO BALANCE');\n      }\n      uint256 quantityPrShare = config.basicDetails.amounts[i];\n      uint256 shares = balance * 1e18 / quantityPrShare;\n      if (shares < initialShares) {\n        initialShares = shares;\n      }\n    }\n    if (initialShares == type(uint256).max) {\n      revert('NO SHARES');\n    }\n    config.basicDetails.initialShares = initialShares;\n\n    if (config.isGoverned) {\n      (address folio, , , , ,) = IFolioDeployer(config.deployer).deployGovernedFolio(\n        config.stToken,\n        config.basicDetails,\n        config.additionalDetails,\n        config.ownerGovParams,\n        config.tradingGovParams,\n        config.govRoles\n      );\n      if (folio != config.expectedTokenAddress) {\n        revert('EXPECTED != ACTUAL');\n      }\n      return IERC20(folio).balanceOf(address(this));\n    } else {\n      (address folio, ) = IFolioDeployer(config.deployer).deployFolio(\n        config.basicDetails,\n        config.additionalDetails,\n        config.owner,\n        config.govRoles.existingTradeProposers,\n        config.govRoles.tradeLaunchers,\n        config.govRoles.vibesOfficers\n      );\n      if (folio != config.expectedTokenAddress) {\n        revert('EXPECTED != ACTUAL');\n      }\n      return IERC20(folio).balanceOf(address(this));\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}