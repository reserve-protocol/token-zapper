import { Address } from '../base/Address'
import { type Token, type TokenQuantity } from '../entities/Token'
import { type Universe } from '../Universe'
import { DestinationOptions, Action, InteractionConvention } from './Action'
import { ContractCall } from '../base/ContractCall'
import { Approval } from '../base/Approval'
import { type OneInchSwapResponse } from '../aggregators/oneInch/oneInchRegistry'
import { parseHexStringIntoBuffer } from '../base/utils'

// OneInch actions should only be dynamically generated by the Searcher and not be added to the exchange-graph
export class OneInchAction extends Action {
  gasEstimate() {
    return BigInt(this.actionQuote.tx.gas)
  }
  async encode(): Promise<ContractCall> {
    const swap = this.actionQuote
    if (swap == null) {
      throw new Error('Failed to generate swap')
    }
    return new ContractCall(
      parseHexStringIntoBuffer(swap.tx.data),
      Address.fromHexString(swap.tx.to),
      BigInt(swap.tx.value),
      this.gasEstimate(),
      `1Inch Swap (${swap.protocols
        .flat(5)
        .map((i: any) => i.name)
        .join(',')})`,
    )
  }

  toString() {
    return `OneInch(path=[${this.actionQuote.protocols
      .flat(5)
      .map((i: any) => i.name)
      .join(',')}])`
  }

  async quote(_: TokenQuantity[]): Promise<TokenQuantity[]> {
    return [
      this.output[0].quantityFromBigInt(BigInt(this.actionQuote.toTokenAmount)),
    ]
  }

  private constructor(
    readonly universe: Universe,
    input: Token,
    output: Token,
    private readonly actionQuote: OneInchSwapResponse
  ) {
    super(
      Address.fromHexString(actionQuote.tx.to),
      [input],
      [output],
      InteractionConvention.ApprovalRequired,
      DestinationOptions.Recipient,
      [new Approval(input, Address.fromHexString(actionQuote.tx.to))]
    )
  }

  static createAction(
    universe: Universe,
    input: Token,
    output: Token,
    quote: OneInchSwapResponse
  ) {
    return new OneInchAction(universe, input, output, quote)
  }
}
