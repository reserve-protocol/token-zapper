"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OneInchAction = void 0;
const Address_1 = require("../base/Address");
const Action_1 = require("./Action");
const ContractCall_1 = require("../base/ContractCall");
const Approval_1 = require("../base/Approval");
const utils_1 = require("../base/utils");
// OneInch actions should only be dynamically generated by the Searcher and not be added to the exchange-graph
class OneInchAction extends Action_1.Action {
    universe;
    actionQuote;
    gasEstimate() {
        return BigInt(this.actionQuote.tx.gas);
    }
    async encode() {
        const swap = this.actionQuote;
        if (swap == null) {
            throw new Error('Failed to generate swap');
        }
        return new ContractCall_1.ContractCall((0, utils_1.parseHexStringIntoBuffer)(swap.tx.data), Address_1.Address.fromHexString(swap.tx.to), BigInt(swap.tx.value), this.gasEstimate(), `1Inch Swap (${swap.protocols
            .flat(5)
            .map((i) => i.name)
            .join(',')})`);
    }
    toString() {
        return `OneInch(path=[${this.actionQuote.protocols
            .flat(5)
            .map((i) => i.name)
            .join(',')}])`;
    }
    async quote(_) {
        return [
            this.output[0].quantityFromBigInt(BigInt(this.actionQuote.toTokenAmount)),
        ];
    }
    constructor(universe, input, output, actionQuote) {
        super(Address_1.Address.fromHexString(actionQuote.tx.to), [input], [output], Action_1.InteractionConvention.ApprovalRequired, Action_1.DestinationOptions.Recipient, [new Approval_1.Approval(input, Address_1.Address.fromHexString(actionQuote.tx.to))]);
        this.universe = universe;
        this.actionQuote = actionQuote;
    }
    static createAction(universe, input, output, quote) {
        return new OneInchAction(universe, input, output, quote);
    }
}
exports.OneInchAction = OneInchAction;
//# sourceMappingURL=OneInch.js.map