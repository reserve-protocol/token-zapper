{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/IFolio.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\ninterface IFolio is IERC20 {\n    // === Events ===\n\n    event AuctionApproved(uint256 indexed auctionId, address indexed from, address indexed to, Auction auction);\n    event AuctionOpened(uint256 indexed auctionId, Auction auction);\n    event AuctionBid(uint256 indexed auctionId, uint256 sellAmount, uint256 buyAmount);\n    event AuctionClosed(uint256 indexed auctionId);\n\n    event FolioFeePaid(address indexed recipient, uint256 amount);\n    event ProtocolFeePaid(address indexed recipient, uint256 amount);\n\n    event BasketTokenAdded(address indexed token);\n    event BasketTokenRemoved(address indexed token);\n    event TVLFeeSet(uint256 newFee, uint256 feeAnnually);\n    event MintFeeSet(uint256 newFee);\n    event FeeRecipientSet(address indexed recipient, uint96 portion);\n    event AuctionDelaySet(uint256 newAuctionDelay);\n    event AuctionLengthSet(uint256 newAuctionLength);\n    event MandateSet(string newMandate);\n    event FolioKilled();\n\n    // === Errors ===\n\n    error Folio__FolioKilled();\n    error Folio__Unauthorized();\n\n    error Folio__EmptyAssets();\n    error Folio__BasketModificationFailed();\n\n    error Folio__FeeRecipientInvalidAddress();\n    error Folio__FeeRecipientInvalidFeeShare();\n    error Folio__BadFeeTotal();\n    error Folio__TVLFeeTooHigh();\n    error Folio__TVLFeeTooLow();\n    error Folio__MintFeeTooHigh();\n    error Folio__ZeroInitialShares();\n\n    error Folio__InvalidAsset();\n    error Folio__InvalidAssetAmount(address asset);\n\n    error Folio__InvalidAuctionLength();\n    error Folio__InvalidSellLimit();\n    error Folio__InvalidBuyLimit();\n    error Folio__AuctionCannotBeOpened();\n    error Folio__AuctionCannotBeOpenedPermissionlesslyYet();\n    error Folio__AuctionNotOngoing();\n    error Folio__AuctionCollision();\n    error Folio__InvalidPrices();\n    error Folio__AuctionTimeout();\n    error Folio__SlippageExceeded();\n    error Folio__InsufficientBalance();\n    error Folio__InsufficientBid();\n    error Folio__ExcessiveBid();\n    error Folio__InvalidAuctionTokens();\n    error Folio__InvalidAuctionDelay();\n    error Folio__InvalidAuctionTTL();\n    error Folio__TooManyFeeRecipients();\n    error Folio__InvalidArrayLengths();\n\n    // === Structures ===\n\n    struct FolioBasicDetails {\n        string name;\n        string symbol;\n        address[] assets;\n        uint256[] amounts; // {tok}\n        uint256 initialShares; // {share}\n    }\n\n    struct FolioAdditionalDetails {\n        uint256 auctionDelay; // {s}\n        uint256 auctionLength; // {s}\n        FeeRecipient[] feeRecipients;\n        uint256 tvlFee; // D18{1/s}\n        uint256 mintFee; // D18{1}\n        string mandate;\n    }\n\n    struct FeeRecipient {\n        address recipient;\n        uint96 portion; // D18{1}\n    }\n\n    struct BasketRange {\n        uint256 spot; // D27{buyTok/share}\n        uint256 low; // D27{buyTok/share} inclusive\n        uint256 high; // D27{buyTok/share} inclusive\n    }\n\n    struct Prices {\n        uint256 start; // D27{buyTok/sellTok}\n        uint256 end; // D27{buyTok/sellTok}\n    }\n\n    /// Auction states:\n    ///   - APPROVED: start == 0 && end == 0\n    ///   - OPEN: block.timestamp >= start && block.timestamp <= end\n    ///   - CLOSED: block.timestamp > end\n    struct Auction {\n        uint256 id;\n        IERC20 sell;\n        IERC20 buy;\n        BasketRange sellLimit; // D27{sellTok/share} min ratio of sell token in the basket, inclusive\n        BasketRange buyLimit; // D27{buyTok/share} max ratio of buy token in the basket, exclusive\n        Prices prices; // D27{buyTok/sellTok}\n        uint256 availableAt; // {s} inclusive\n        uint256 launchTimeout; // {s} inclusive\n        uint256 start; // {s} inclusive\n        uint256 end; // {s} inclusive\n        // === Gas optimization ===\n        uint256 k; // D18{1} price = startPrice * e ^ -kt\n    }\n\n    function distributeFees() external;\n\n    function folio() external view returns (address[] memory _assets, uint256[] memory _amounts);\n    function AUCTION_APPROVER() external view returns (bytes32);\n    function AUCTION_LAUNCHER() external view returns (bytes32);\n    function BRAND_MANAGER() external view returns (bytes32);\n\n    function mint(uint256 shares, address receiver) external returns (address[] memory _assets, uint256[] memory _amounts);\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address[] calldata assets,\n        uint256[] calldata minAmountsOut\n    ) external returns (uint256[] memory _amounts);\n}\n\n\ninterface IGovernanceDeployer {\n    struct GovParams {\n        // Basic Parameters\n        uint48 votingDelay; // {s}\n        uint32 votingPeriod; // {s}\n        uint256 proposalThreshold; // D18{1}\n        uint256 quorumPercent; // in percent, e.g 4 for 4%\n        uint256 timelockDelay; // {s}\n        // Roles\n        address[] guardians; // Canceller Role\n    }\n\n    function deployGovernanceWithTimelock(\n        IGovernanceDeployer.GovParams calldata govParams,\n        IVotes stToken\n    ) external returns (address governor, address timelock);\n}\n\nstruct GovRoles {\n  address[] existingTradeProposers;\n  address[] tradeLaunchers;\n  address[] vibesOfficers;\n}\n\n\ninterface IFolioDeployer {\n  error FolioDeployer__LengthMismatch();\n\n  event FolioDeployed(address indexed folioOwner, address indexed folio, address folioAdmin);\n  event GovernedFolioDeployed(\n      address indexed stToken,\n      address indexed folio,\n      address ownerGovernor,\n      address ownerTimelock,\n      address tradingGovernor,\n      address tradingTimelock\n  );\n\n\n  function folioImplementation() external view returns (address);\n\n\n  function deployFolio(\n    IFolio.FolioBasicDetails calldata basicDetails,\n    IFolio.FolioAdditionalDetails calldata additionalDetails,\n    address owner,\n    address[] memory auctionApprovers,\n    address[] memory auctionLaunchers,\n    address[] memory brandManagers,\n    bytes32 deploymentNonce\n  ) external returns (address folio, address proxyAdmin);\n\n  function deployGovernedFolio(\n    IVotes stToken,\n    IFolio.FolioBasicDetails calldata basicDetails,\n    IFolio.FolioAdditionalDetails calldata additionalDetails,\n    IGovernanceDeployer.GovParams calldata ownerGovParams,\n    IGovernanceDeployer.GovParams calldata tradingGovParams,\n    GovRoles calldata govRoles,\n    bytes32 deploymentNonce\n  )\n    external\n    returns (\n        address folio,\n        address proxyAdmin,\n        address ownerGovernor,\n        address ownerTimelock,\n        address tradingGovernor,\n        address tradingTimelock\n    );\n\n\n}\n"
    },
    "contracts/weiroll-helpers/FolioMintRedeem.sol": {
      "content": "// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport { IFolio } from '../IFolio.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { Math } from '@openzeppelin/contracts/utils/math/Math.sol';\ncontract FolioMintRedeem {\n  function _fromAssets(\n    address[] memory assets,\n    uint256[] memory amounts\n  ) internal view returns (uint256 shares) {\n    uint256 total = 0;\n    for (uint256 i; i < assets.length; i++) {\n      uint256 assetBal = IERC20(assets[i]).balanceOf(address(this));\n      uint256 qtyPrShare = amounts[i];\n      // {share} = {tok} / {tok/share}\n      total = Math.max(total, (assetBal * 1e18) / qtyPrShare);\n    }\n    return total;\n  }\n\n  function mint(IFolio folio) external returns (uint256 shares) {\n    (\n      address[] memory assets,\n      uint256[] memory amounts\n    ) = folio.folio();\n\n    uint256 shares = _fromAssets(assets, amounts);\n\n    uint256 balanceBefore = IERC20(address(folio)).balanceOf(address(this));\n    folio.mint(shares, address(this));\n    uint256 balanceAfter = IERC20(address(folio)).balanceOf(address(this));\n\n    return balanceAfter - balanceBefore;\n  }\n\n  function redeem(IFolio folio, uint256 shares) external {\n    (\n      address[] memory assets,\n      uint256[] memory amounts\n    ) = folio.folio();\n    for (uint256 i; i < assets.length; i++) {\n      amounts[i] = 0;\n    }\n    folio.redeem(shares, address(this), assets, amounts);\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}