{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/IFolio.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IVotes } from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\ninterface IFolio {\n    // === Events ===\n\n    event TradeApproved(\n        uint256 indexed tradeId,\n        address indexed from,\n        address indexed to,\n        uint256 startPrice,\n        uint256 endPrice,\n        uint256 sellLimitSpot,\n        uint256 sellLimitLow,\n        uint256 sellLimitHigh,\n        uint256 buyLimitSpot,\n        uint256 buyLimitLow,\n        uint256 buyLimitHigh\n    );\n    event TradeOpened(\n        uint256 indexed tradeId,\n        uint256 startPrice,\n        uint256 endPrice,\n        uint256 sellLimit,\n        uint256 buyLimit,\n        uint256 start,\n        uint256 end\n    );\n    event Bid(uint256 indexed tradeId, uint256 sellAmount, uint256 buyAmount);\n    event TradeKilled(uint256 indexed tradeId);\n\n    event BasketTokenAdded(address indexed token);\n    event BasketTokenRemoved(address indexed token);\n    event FolioFeeSet(uint256 newFee, uint256 feeAnnually);\n    event MintingFeeSet(uint256 newFee);\n    event FeeRecipientSet(address indexed recipient, uint96 portion);\n    event TradeDelaySet(uint256 newTradeDelay);\n    event AuctionLengthSet(uint256 newAuctionLength);\n    event FolioKilled();\n\n    // === Errors ===\n\n    error Folio__FolioKilled();\n    error Folio__Unauthorized();\n\n    error Folio__EmptyAssets();\n    error Folio__BasketModificationFailed();\n\n    error Folio__FeeRecipientInvalidAddress();\n    error Folio__FeeRecipientInvalidFeeShare();\n    error Folio__BadFeeTotal();\n    error Folio__FolioFeeTooHigh();\n    error Folio__FolioFeeTooLow();\n    error Folio__MintingFeeTooHigh();\n\n    error Folio__InvalidAsset();\n    error Folio__InvalidAssetAmount(address asset);\n\n    error Folio__InvalidAuctionLength();\n    error Folio__InvalidTradeId();\n    error Folio__InvalidSellLimit();\n    error Folio__InvalidBuyLimit();\n    error Folio__TradeCannotBeOpened();\n    error Folio__TradeCannotBeOpenedPermissionlesslyYet();\n    error Folio__TradeNotOngoing();\n    error Folio__TradeCollision();\n    error Folio__InvalidPrices();\n    error Folio__TradeTimeout();\n    error Folio__SlippageExceeded();\n    error Folio__InsufficientBalance();\n    error Folio__InsufficientBid();\n    error Folio__ExcessiveBid();\n    error Folio__InvalidTradeTokens();\n    error Folio__InvalidTradeDelay();\n    error Folio__InvalidTradeTTL();\n    error Folio__TooManyFeeRecipients();\n    error Folio__InvalidArrayLengths();\n\n    // === Structures ===\n\n    struct FolioBasicDetails {\n        string name;\n        string symbol;\n        address[] assets;\n        uint256[] amounts; // {tok}\n        uint256 initialShares; // {share}\n    }\n\n    struct FolioAdditionalDetails {\n        uint256 tradeDelay; // {s}\n        uint256 auctionLength; // {s}\n        FeeRecipient[] feeRecipients;\n        uint256 folioFee; // D18{1/s}\n        uint256 mintingFee; // D18{1}\n    }\n\n    struct FeeRecipient {\n        address recipient;\n        uint96 portion; // D18{1}\n    }\n\n    struct Range {\n        uint256 spot; // D27{buyTok/share}\n        uint256 low; // D27{buyTok/share} inclusive\n        uint256 high; // D27{buyTok/share} inclusive\n    }\n\n    /// Trade states:\n    ///   - APPROVED: start == 0 && end == 0\n    ///   - OPEN: block.timestamp >= start && block.timestamp <= end\n    ///   - CLOSED: block.timestamp > end\n    struct Trade {\n        uint256 id;\n        IERC20 sell;\n        IERC20 buy;\n        Range sellLimit; // D27{sellTok/share} min ratio of sell token to shares allowed, inclusive\n        Range buyLimit; // D27{buyTok/share} min ratio of sell token to shares allowed, exclusive\n        uint256 startPrice; // D27{buyTok/sellTok}\n        uint256 endPrice; // D27{buyTok/sellTok}\n        uint256 availableAt; // {s} inclusive\n        uint256 launchTimeout; // {s} inclusive\n        uint256 start; // {s} inclusive\n        uint256 end; // {s} inclusive\n        // === Gas optimization ===\n        uint256 k; // D18{1} price = startPrice * e ^ -kt\n    }\n\n    function distributeFees() external;\n}\n\n\ninterface IGovernanceDeployer {\n    struct GovParams {\n        // Basic Parameters\n        uint48 votingDelay; // {s}\n        uint32 votingPeriod; // {s}\n        uint256 proposalThreshold; // D18{1}\n        uint256 quorumPercent; // in percent, e.g 4 for 4%\n        uint256 timelockDelay; // {s}\n        // Roles\n        address guardian; // Canceller Role\n    }\n\n    function deployGovernanceWithTimelock(\n        IGovernanceDeployer.GovParams calldata govParams,\n        IVotes stToken\n    ) external returns (address governor, address timelock);\n}\n\nstruct GovRoles {\n    address[] existingTradeProposers;\n    address[] tradeLaunchers;\n    address[] vibesOfficers;\n}\n\n\ninterface IFolioDeployer {\n  error FolioDeployer__LengthMismatch();\n\n  event FolioDeployed(address indexed folioOwner, address indexed folio, address folioAdmin);\n  event GovernedFolioDeployed(\n      address indexed stToken,\n      address indexed folio,\n      address ownerGovernor,\n      address ownerTimelock,\n      address tradingGovernor,\n      address tradingTimelock\n  );\n\n\n  function folioImplementation() external view returns (address);\n\n  function deployFolio(\n    IFolio.FolioBasicDetails calldata basicDetails,\n    IFolio.FolioAdditionalDetails calldata additionalDetails,\n    address owner,\n    address[] memory tradeProposers,\n    address[] memory tradeLaunchers,\n    address[] memory vibesOfficers\n) external returns (address folio_, address folioAdmin_);\n  function deployGovernedFolio(\n    IVotes stToken,\n    IFolio.FolioBasicDetails calldata basicDetails,\n    IFolio.FolioAdditionalDetails calldata additionalDetails,\n    IGovernanceDeployer.GovParams calldata ownerGovParams,\n    IGovernanceDeployer.GovParams calldata tradingGovParams,\n    GovRoles calldata govRoles\n)\n    external\n    returns (\n        address folio,\n        address proxyAdmin,\n        address ownerGovernor,\n        address ownerTimelock,\n        address tradingGovernor,\n        address tradingTimelock\n    );\n\n\n}\n"
    },
    "contracts/weiroll-helpers/DeployFolioHelper.sol": {
      "content": "\n// SPDX-License-Identifier: BlueOak-1.0.0\npragma solidity 0.8.17;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract DeployFolioHelper {\n  function deployFolio(\n      address deployer,\n      address expectedTokenAddress,\n      bool isGoverned,\n      bytes memory encodedFolioDeployerCall\n  ) external returns (uint256) {\n    (bool success, bytes memory result) = address(deployer).call(encodedFolioDeployerCall);\n    if (!success) {\n      assembly {\n        revert(add(result, 32), mload(result))\n      }\n    }\n    if (isGoverned) {\n      (address folio, , , , , ) = abi.decode(result, (address, address, address, address, address, address));\n      if (folio != expectedTokenAddress) {\n        revert('EXPECTED != ACTUAL');\n      }\n\n      return IERC20(expectedTokenAddress).balanceOf(address(this));\n    } else {\n      (address folio, ) = abi.decode(result, (address, address));\n      if (folio != expectedTokenAddress) {\n        revert('EXPECTED != ACTUAL');\n      }\n\n      return IERC20(expectedTokenAddress).balanceOf(address(this));\n    }\n    \n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}